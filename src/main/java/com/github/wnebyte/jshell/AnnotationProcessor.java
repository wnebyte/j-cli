package com.github.wnebyte.jshell;

import java.lang.reflect.Method;
import java.util.*;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import com.google.common.collect.Sets;
import com.github.wnebyte.jshell.exception.config.IllegalAnnotationException;
import static com.github.wnebyte.jshell.util.AnnotationUtil.*;

/**
 * This class declares public and private methods for building an associative data-structure that
 * maps regular expressions to Commands, where each Command can not match against more than one of the
 * built regular expressions.
 */
final class AnnotationProcessor {

    /**
     * Processes a <code>Set</code> of Commands.
     */
    final Map<Pattern, Command> process(final Set<Command> transientCommands)
            throws IllegalAnnotationException
    {
        // commands
        Map<Pattern, Command> commands = new HashMap<>(transientCommands.size());
        // set of signatures generated by all of the commands
        Set<List<String>> signatures = new HashSet<>(transientCommands.size());

        // iterate the commands
        for (Command command : transientCommands) {
            Method method = command.getMethod();
            method.setAccessible(true);

            if (!(isAnnotated(method))) {
                throw new IllegalAnnotationException(
                        "\t\n" + "Method " + method + " is not annotated with: " +
                                com.github.wnebyte.jshell.annotation.Command.class.toString() + "."
                );
            }

            // signature check
            Set<List<String>> signature = generateSignatures(command);
            boolean duplicate = !addSignature(signatures, signature);

            // assert that signature has not already been produced
            if (duplicate) {
                throw new IllegalAnnotationException(
                        "\t\n" + "The named properties of a Command may not collide with those of another Command.\n" +
                                 "Command Signature " + Arrays.toString(signature.toArray()) + " has already been generated."
                );
            }
            // assert that every non-positional argument has a distinct name
            List<String> names = command.getArguments().stream()
                    .filter(argument -> !(argument instanceof Positional))
                    .map(Argument::getName)
                    .collect(Collectors.toList());
            if (!distinct(names)) {
                throw new IllegalAnnotationException(
                        "\t\n" + "The named properties of a Command must all be distinct.\n" +
                                command.getMethod() + " -> " +
                                command.getName() + " " + Arrays.toString(names.toArray())
                );
            }

            // build regular expression key
            StringBuilder keyBuilder = new StringBuilder();
            keyBuilder.append("^")
                    .append(command.hasPrefix() ? command.getPrefix().concat("\\s") : "")
                    .append(command.getName())
                    .append(permute(command.getArguments()))
                    .append("$");
            // set command signature and compile pattern
            command.setSignature(signature);
            commands.put(Pattern.compile(keyBuilder.toString()), command);
        }

        signatures = null;
        return commands;
    }

    /**
     * Verifies that the elements of the specified <code>List</code> are all distinct.
     */
    @SuppressWarnings("StringEquality")
    private boolean distinct(final List<String> values) {
        if (values == null) { return true; }
        // iterate of the values
        for (String value : values) {
            // fetch the "not this" values
            List<String> other = values.stream()
                    .filter(s -> !(s == value))
                    .collect(Collectors.toList());
            // check for equality
            boolean taken = other.stream()
                    .anyMatch(s -> (s.equals(value)));
            // if equal return false
            if (taken) {
                return false;
            }
        }
        return true;
    }

    /**
     * Generates a <code>Set</code> of signatures from the specified <code>Command</code>.
     * <p></p>
     */
    private Set<List<String>> generateSignatures(final Command command) {
        Set<List<String>> set = new HashSet<>();
        List<String> list = new ArrayList<>();
        if (command.hasPrefix()) {
            list.add(command.getPrefix());
        }
        list.add(command.getName());
        list.addAll(command.getArguments().stream()
                .filter(argument -> argument instanceof Positional)
                .map(Argument::getName)
                .sorted()
                .collect(Collectors.toList()));
        list.addAll(command.getArguments().stream()
                .filter(argument -> argument instanceof Required)
                .map(Argument::getName)
                .sorted()
                .collect(Collectors.toList()));
        Set<String> optionalNames = command.getArguments().stream()
                .filter(argument -> argument instanceof Optional)
                .map(Argument::getName)
                .collect(Collectors.toSet());
        Set<Set<String>> powerSet = Sets.powerSet(optionalNames);
        for (Set<String> s : powerSet) {
            set.add(new ArrayList<String>(list) {
                { addAll(s); }
            });
        }
        return set;
    }

    /**
     * Adds the elements of the 2nd <code>Set</code> to the 1st <code>Set</code>, and returns whether the
     * union of the two is <code>equal</code> to zero.
     */
    private boolean addSignature(final Set<List<String>> set1, final Set<List<String>> set2) {
        for (List<String> element : set2) {
            boolean exists = !set1.add(element);
            if (exists) {
                return false;
            }
        }
        return true;
    }

    /**
     * Permutes the regular expressions of the specified Arguments, and returns the result
     * as a <code>String</code>.
     */
    private String permute(final List<Argument> arguments) {
        // if there are no arguments to permute, return an empty string
        if ((arguments == null) || (arguments.size() == 0)) {
            return "";
        }

        String str  = "(";
        int i = 0;
        // init set of unique permutations
        Set<List<String>> set = powerSet(arguments);
        for (List<String> permutation : set) {
            // permutation as a string
            String string = Arrays.toString(permutation.toArray());
            // add opening and closing parenthesis around the permutation
            str = str.concat("(").concat(string.substring(1, string.length() - 1))
                    .concat(")");
            // add 'or' regex for every permutation but the last
            if (i < set.size() - 1) {
                str = str.concat("|");
            }
            i++;
        }
        // normalize and return the string
        return str.replace(", ", "")
                .concat(")");
    }

    /**
     * @return the powerset of the specified arguments, with any positional arguments at their
     * appropriate position.
     */
    /*
    each element in the powerset has the same length -- the length of the specified list of arguments
     */
    private Set<List<String>> powerSet(final List<Argument> arguments) {
        // init a set for all the regex-permutations
        Set<List<String>> set = new HashSet<>();
        // init a linked list for the regex's belonging to the non-positional arguments
        LinkedList<String> nonPositional = arguments.stream().filter(arg -> !(arg instanceof Positional))
                .map(Argument::getRegex)
                .collect(Collectors.toCollection(LinkedList::new));

        /*
        arguments contain no non-positional arguments,
        return a list of their regular expressions
         */
        if (nonPositional.isEmpty()) {
            set.add(arguments.stream()
                    .map(Argument::getRegex)
                    .collect(Collectors.toList()));
            return set;
        }

        // iterate over the non-positional argument regex's
        for (int i = 0; i < nonPositional.size(); i++)
        {
            // shift the regex linked list to the left <<
            String head = nonPositional.pop();
            nonPositional.add(head);

            // init a mirror list of the linked list
            List<String> list = new ArrayList<>(nonPositional);

            // iterate over the mirror list
            for (int j = 0; j < list.size(); j++) {
                if (j != 0) {
                    // swap the elements of the mirror list around
                    Collections.swap(list, j, j - 1);
                }
                // for each permutation of the mirror list, insert back the positional arguments at their set positions
                set.add(new ArrayList<String>(list){
                    {
                        arguments.stream().filter(arg -> (arg instanceof Positional))
                                .forEach(arg -> {
                                    Positional argument = (Positional) arg;
                                    add(argument.getPosition(), argument.getRegex());
                                });
                    }
                });
            }
        }
        return set;
    }
}
